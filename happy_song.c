/************************************************************************************
* 
* 程序功能： 本程序实现乐曲《欢乐颂》的演奏，并在LCD上实时显示简谱
* 连线：     蜂鸣器
             	P3.2------IN
			 LCD
         	 	P0----D0-7
	         	P2----D8-15
			 查询式键盘
			 	P3.1-----C7区KEY0

/************************************************************************************
// 引用外部头文件
*************************************************************************************/
#include <reg51.h>
#include <intrins.h> 
#include <7920.h>
#include <string.h>

/************************************************************************************
// 常量及全局变量定义
*************************************************************************************/
#define uchar unsigned char
#define ulong unsigned long
#define uint unsigned int

sbit Music_out=P3^2;
sbit ch=P3^1;

//song[]中存放乐谱，其中高4位代表音符的高低（频率），通过在note[]中查询得到，低4位表示音符的节拍（演奏时间）
code uchar song[]={0x64,0x64,0x74,0x84,0x84,0x74,0x64,0x54,
                   0x44,0x44,0x54,0x64,0x66,0x52,0x58,
				   0x64,0x64,0x74,0x84,0x84,0x74,0x64,0x54,
				   0x44,0x44,0x54,0x64,0x56,0x42,0x48,
				   0x54,0x54,0x64,0x44,0x54,0x62,0x72,0x64,0x44,
				   0x54,0x62,0x72,0x64,0x54,0x44,0x54,0x14,0x64,
				   0x64,0x64,0x74,0x84,0x84,0x74,0x64,0x72,0x52,
				   0x44,0x44,0x54,0x64,0x56,0x42,0x48,0x00};

//note[]中存放每一音符频率所对应的定时器的初值
code int note[]={0x0000,0xFB03,0xFB8E,0xFC0B,0xFC43,0xFCAB,0xFD08,0xFD32,
                 0xFD81,0xFDC7,0xFE05,0xFE21,0xFE55,0xFE83,0xFE99,0xFEC0};
uchar i=0,l;
uchar hi_note, low_note;


/************************************************************************************
// 子函数声明
*************************************************************************************/
void delay_ms(uchar ch);
void timer1_INIT(void);
void singing(void);
void lcd_display(void);
bit CheckState(void);
void delay(void);
/************************************************************************************
// 主程序 
*************************************************************************************/
void main()
{
	timer1_INIT();
	init_ST7920();
	while(1)
	{
		if(CheckState())
		{
			delay();
			if(CheckState())
			{
				init_ST7920();
				singing();
				TR1=0;
				init_ST7920();
				Disp_ST7920_String(0,0,"WONDERFUL!!");
				Disp_ST7920_String(0,1,"YOU ARE A GENIUS");
				Disp_ST7920_String(0,2,"!!");
			}
		}
	}
	 
}
/************************************************************************************
// 读节拍码程序，每个字节中的高4位代表音符高低（频率），低成4位代表音符的节拍（演奏时间）
*************************************************************************************/
void singing(void)
{
	uchar beat, temp;
	l=strlen(song);
    for(i=0;i<l;i++)
    {	
		if(i==46) init_ST7920();
		if(i<12)
			Disp_ST7920_String(0,0,"3345|5432|1123|");
		else if(i<22)
			Disp_ST7920_String(0,1,"3.22-|3345|5432|");
		else if(i<34)
			Disp_ST7920_String(0,2,"1123|2.11-|2231|");
		else if(i<46)
			Disp_ST7920_String(0,3,"23431|23432|1253|");
		else if(i<60)
   			Disp_ST7920_String(0,0,"3345|54342|1123|");
		else if(i<l)
			Disp_ST7920_String(0,1,"2.11-|");	
    	temp=song[i];       //读出乐谱的一个字节
	    beat=temp&0x0F;    //取出低4位，这就是拍子，是乐符演奏的时间
	    temp=temp>>4&0x0F;  //取出高4位当成音符频率
	    if(temp==0)         //如果频率为0表示休止符
	    	TR1=0;
	    else
	    {
	    	hi_note=note[temp]>>8;   //根据音符的频率得到Timer1的计数值
	    	low_note=note[temp]&0x00FF;
			TR1=1;                   //启动定时器
	    }
	    delay_ms(beat);           //延长拍子对应的时间 beat/4 拍
		
			
	}
}


/************************************************************************************
// 定时器具中断初始化 
*************************************************************************************/
void timer1_INIT(void)
{
	EA=0;
    TR1=0;
    TMOD=0x10;
    ET1=1;
    EA=1;
}


/************************************************************************************
// 定时器1中断入口程序 
*************************************************************************************/
void TIMER1_ISR(void) interrupt 3
{
    TR1=0;
    TL1=low_note;
    TH1=hi_note;
	TR1=1;
	Music_out=~Music_out;
}


/************************************************************************************
// 延时程序，单位延时时间为100ms
*************************************************************************************/
void delay_ms(uchar ch)
{
	uchar i, j, k;
	for(i=0;i<ch;i++)
	for(j=0;j<135;j++)
	for(k=0;k<245;k++);
}

bit CheckState(void)
{
	bit state=0;				
	if(ch!=1)              
        state=1; 
	else 
		state=0;
	return(state);
}

void delay(void)
{
   uchar m, n;
   for (n=0;n<10;n++)
   for (m=0;m<255;m++);
}